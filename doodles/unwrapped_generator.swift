func type(i: Int) -> String {
    return "T\(i)"
}


func argumentType(i: Int) -> String {
    let t = type(i)

    if i == 1 {
        return "\(t)?"
    } else {
        return "@autoclosure () -> \(t)?"
    }
}


func variable(i: Int) -> String {
    return "x\(i)"
}


func access(i: Int) -> String {
    let v = variable(i)

    if i == 1 {
        return v
    } else {
        return "\(v)()"
    }
}


func indent(level: Int) -> String {
    var s = ""

    for _ in 0 ..< level {
        s += "    "
    }

    return s
}


print("// This is how I try to deal with deserialization of JSON objects\n// with multiple properties using [SwiftyJSON][] (read: without going\n// full [Argo][]).\n//\n// This code is generated by `unwrapped_generator.swift`.\n//\n//   [SwiftyJSON]: https://github.com/SwiftyJSON/SwiftyJSON\n//   [Argo]: https://github.com/thoughtbot/Argo\n//\n\n")


for iMax in 2 ... 10 {
    let indices = Array(1 ... iMax)

    print("func unwrapped<")
    print(", ".join(indices.map(type)))
    print(">(")
    print(", ".join(indices.map { "\(variable($0)): \(argumentType($0))" }))
    print(") -> (")
    print(", ".join(indices.map(type)))
    print(")? {\n")

    var level = 1

    for i in indices {
        print(indent(level))
        print("if let \(variable(i)) = \(access(i)) {\n")
        level += 1
    }

    print(indent(level))
    print("return (")
    print(", ".join(indices.map(variable)))
    print(")\n")

    while level > 1 {
        level -= 1
        print(indent(level))
        print("}\n")
    }

    print("\n    return nil\n}\n\n")
}
